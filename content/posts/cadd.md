+++
title = 'C语言中的整数运算'
date = 2024-09-27T16:15:48+08:00
draft = false
+++

## 从一道练习题说起

刚开始学习C语言，老师布置了一道题：

> **推算钟点**
>
> 若告诉你现在的时间，请问过若干分钟后是什么时间？
>
> 请编写程序，输入现在的时间(小时数、分钟数)和所过的时间(分钟数)，计算并输出未来的时间(时、分)。

题目看似并不困难，根据输入输出格式的要求，很快就写出了程序：

```C
#include <stdio.h>

int main()
{
    int hour, minute, pass;
    scanf("%d:%d", &hour, &minute);
    scanf("%d", &pass);

    minute += pass;
    hour += (minute / 60);
    minute %= 60;    
    hour %= 24;
    printf("%02d:%02d\n", hour, minute);
    
    return 0;
}
```

提交。遗憾，10个测试例通过了9各，有一个没有通过。讨厌的时我看不到测试例，不知道因为啥不通过。
思索良久，不得其解。看到排行榜上同宿舍的同学已经提交通过，遂请教。同学的代码如下：

```C
#include <stdio.h>

int main() {
    int hour, min;
    int pass;
    scanf_s("%d:%d\n", &hour, &min);
    scanf_s("%d", &pass);
    min += pass;
    while (min / 60 != 0) {
        min -= 60;
        hour++;
    }
    while (hour / 24 != 0) {
        hour -= 24;
    }
    printf("%02d:%02d\n", hour, min);
    return 0;
}
```

看过之后，感觉我和她的代码并无本质区别，更觉奇怪。后在同学群中看到有同学讨论，说把数据
类型由 `int` 改为 `unsigned` 即可。顿悟：原来是测试例中有一个超级大数，加法运算后溢出了。

不通过的原因并不神秘，修改后的代码也并不高明，修改后也并不能根本避免溢出的发生，只是允许
输入的数字更大了一点而已。虽然知道不通过的原因了，但原来的疑惑更深了：同学的代码也有加法
运算，她的代码为什么不受溢出的影响？

思索一番，终于明白：同学的代码发生了两次溢出，负负得正，阴差阳错结果是对的！个中原因要从
整数在计算机中的表示方式说起。

计算机用二进制来表示数。无论用多少个二进制位来表示一个数，它的表示能力总是有限的，因为它
总共有 2<sup>n</sup> 种状态，也就是说总有一些数它是无法表达的。这就带来了一个问题：当在
计算机中对数进行运算时，有可能发生溢出现象：即运算结果超出了计算机的表达能力。

当前计算机系统用 [`2` 的补码](https://en.wikipedia.org/wiki/Two%27s_complement)
来表示有符号的整数。在这种表示法中，二进制数的最高位表示正负号，0为正，1为负。当两个正数
相加时，如果结果足够大，可能因为进位导致最高位由0变为1，从而成为一个负数。相应的，当两个
负数相加时，如果结果足够小，也可能因为进位导致最高位由1变为0，从而成为一个正数。这种情况
就是溢出。

因为计算机的表达能力有限，溢出无法从根本上避免，但可以检测出来。两个正数或者两个负数相加，
如果正负号发生了变化，即表明发生了溢出。正溢出时计算机得到的结果相当于和减去了2<sup>n</sup>，
负溢出时计算机得到的结果相当于和加上了2<sup>n</sup>。

回到同学的程序，当测试例的数值较大时，`min` 和 `pass` 相加发生正溢出，结果在数学上相当于
`min + pass - `2<sup>n</sup>，这是一个很负的数。在随后的 `while` 循环里，每次又从这个
数减去 60，导致它越来越负，所以除以 60 的结果不可能为 0。可以想象，循环里最终会发生一次负
溢出，结果在数学上相当于 `min + pass - `2<sup>n</sup> - `60 * s` + 2<sup>n</sup>，
`s`表示循环次数。两次溢出，导致了戏剧性的正确结果！